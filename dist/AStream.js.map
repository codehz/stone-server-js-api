{"version":3,"file":"AStream.js","sourceRoot":"","sources":["../src/AStream.ts"],"names":[],"mappings":";;AAAA,SAAgB,KAAK;IAInB,MAAM,UAAU,GAGZ,EAAE,CAAC;IACP,MAAM,OAAO,GAAG,IAAI,OAAO,CAAI,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE,CACjD,MAAM,CAAC,MAAM,CAAC,UAAU,EAAE,EAAE,OAAO,EAAE,MAAM,EAAE,CAAC,CAC/C,CAAC;IACF,OAAO,MAAM,CAAC,MAAM,CAAC,OAAO,EAAE,UAAU,CAGvC,CAAC;AACJ,CAAC;AAfD,sBAeC;AAWD,SAAgB,WAAW,CAAI,IAAgB,EAAE,GAAa;IAC5D,IAAI,EAAE,GAAG,KAAK,EAAK,CAAC;IACpB,IAAI,KAAK,GAAe,KAAK,CAAC,CAAC;IAC/B,KAAK,SAAS,CAAC,CAAC,MAAM;QACpB,IAAI;YACF,SAAS;gBACP,MAAM,KAAK,GAAG,MAAM,EAAE,CAAC;gBACvB,IAAI,CAAC,EAAE;oBAAE,MAAM;gBACf,MAAM,KAAK,CAAC;gBACZ,OAAO,KAAK,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC;oBAAE,MAAM,KAAK,CAAC,KAAK,EAAG,CAAC;gBACvD,KAAK,GAAG,KAAK,CAAC,CAAC;aAChB;SACF;gBAAS;YACR,IAAI,EAAE,CAAC;SACR;IACH,CAAC;IACD,OAAO,MAAM,CAAC,MAAM,CAAC,MAAM,EAAE,EAAE;QAC7B,KAAK,CAAC,GAAG,CAAC,GAAG,GAA8B;YACzC,KAAK,MAAM,GAAG,IAAI,GAAG,EAAE;gBACrB,MAAM,KAAK,GAAG,MAAM,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;gBACzC,IAAI,KAAK,EAAE;oBACT,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;oBAClB,IAAI,GAAG,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC;wBAAE,KAAK,CAAC,KAAK,EAAE,CAAC;oBAC3C,OAAO,CAAC,QAAQ,EAAE,CAAC;iBACpB;qBAAM;oBACL,KAAK,GAAG,EAAE,CAAC;oBACX,MAAM,CAAC,GAAG,EAAE,CAAC;oBACb,EAAE,GAAG,KAAK,EAAK,CAAC;oBAChB,CAAC,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;iBAClB;aACF;QACH,CAAC;QACD,IAAI,CAAC,CAAM;YACT,EAAE,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;QACf,CAAC;KACF,CAAC,CAAC;AACL,CAAC;AApCD,kCAoCC;AAEM,KAAK,UAAU,aAAa,CACjC,MAA0B,EAC1B,OAA4C;IAE5C,IAAI,KAAK,EAAE,MAAM,EAAE,IAAI,MAAM;QAAE,MAAM,OAAO,CAAC,EAAE,CAAC,CAAC;AACnD,CAAC;AALD,sCAKC","sourcesContent":["export function defer<T>(): Promise<T> & {\n  resolve: (i?: T | PromiseLike<T>) => void;\n  reject: (i: any) => void;\n} {\n  const properties: {\n    resolve?: (i?: T | PromiseLike<T>) => void;\n    reject?: (i: any) => void;\n  } = {};\n  const promise = new Promise<T>((resolve, reject) =>\n    Object.assign(properties, { resolve, reject })\n  );\n  return Object.assign(promise, properties) as Promise<T> & {\n    resolve: (i?: T | PromiseLike<T>) => void;\n    reject: (i: any) => void;\n  };\n}\n\nexport type ReadOnlyAStream<T> = AsyncIterableIterator<T>;\n\nexport type WriteOnlyAStream<T> = {\n  put: (...inp: Array<T | PromiseLike<T>>) => Promise<void>;\n  fail: (i: any) => void;\n};\n\nexport type AStream<T> = ReadOnlyAStream<T> & WriteOnlyAStream<T>;\n\nexport function makeAStream<T>(stop: () => void, pre?: boolean): AStream<T> {\n  let xp = defer<T>();\n  let cache: void | T[] = void 0;\n  async function* stream(): AsyncIterableIterator<T> {\n    try {\n      for (;;) {\n        const value = await xp;\n        if (!xp) break;\n        yield value;\n        while (cache && cache.length > 0) yield cache.shift()!;\n        cache = void 0;\n      }\n    } finally {\n      stop();\n    }\n  }\n  return Object.assign(stream(), {\n    async put(...inp: Array<T | PromiseLike<T>>) {\n      for (const sig of inp) {\n        const value = await Promise.resolve(sig);\n        if (cache) {\n          cache.push(value);\n          if (pre && cache.length > 1) cache.shift();\n          console.groupEnd();\n        } else {\n          cache = [];\n          const p = xp;\n          xp = defer<T>();\n          p.resolve(value);\n        }\n      }\n    },\n    fail(i: any) {\n      xp.reject(i);\n    }\n  });\n}\n\nexport async function handleAStream<T>(\n  stream: ReadOnlyAStream<T>,\n  handler: (inp: T) => void | PromiseLike<any>\n) {\n  for await (const it of stream) await handler(it);\n}\n"]}